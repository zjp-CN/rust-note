
# async closure

* <https://hackmd.io/@compiler-errors/async-closures>：编译器开发者 @compiler-errors 实现异步闭包的一些记录，尤其明确了
  lending `Fn{Once, Mut}` 与当前 giving `Fn{Once, Mut}` 相比，在返回类型上应该不同的细节。
* <https://github.com/rust-lang/rfcs/pull/3668>: Async closures RFC；很好地介绍了异步闭包的 APIs 与设计思路


# unsafe in edition 2024

目前来看，Rust edition 2024 将在 unsafe Rust 相关代码上产生重大变化 （看板： https://github.com/orgs/rust-lang/projects/43 ）：
* Make unsafe_op_in_unsafe_fn warn-by-default： https://github.com/rust-lang/rust/issues/123916
* RFC 3484: Unsafe Extern Blocks： https://github.com/rust-lang/rust/issues/123743
* RFC 3325: unsafe attributes：https://github.com/rust-lang/rust/issues/123757
* Disallow *references* to static mut：https://github.com/rust-lang/rust/issues/114447
  * static_mut_refs: Should the lint cover hidden references? https://github.com/rust-lang/rust/issues/123060

# self-referential

[The Inconceivable Types of Rust: How to Make Self-Borrows Safe](https://blog.polybdenum.com/2024/06/07/the-inconceivable-types-of-rust-how-to-make-self-borrows-safe.html)：
* 围绕剖析 async fn 的状态机，从类型系统的角度，站在非常高级的视角审视 Rust 在自引用问题上面临的种种问题，并提出解决方案。
* 我认为，该文章至少可以回答以下一些问题：
  * async fn 的 Future 状态机之下、跨 await 点上的各种幽暗细节是什么？
  * 从一个假想的、完整的 Rust 类型系统视角，在自引用问题上 partial move、生命周期和 Drop 的交互是什么样的？
  * 当我们在 safe Rust 中，支持零成本手写 Future 状态机的类型系统将会是什么样？
  * 是什么阻止我们以安全的方式，零成本实现自引用？
  * 如何维持 Rust 核心设计来深度拓展自引用？
* 社区其他人对此的讨论
  * [该文章在 Reddit 上的讨论](https://www.reddit.com/r/rust/comments/1da2hz9/the_inconceivable_types_of_rust_how_to_make/)
  * [A Unified Typesystem: Partial, Variant, Borrowed Types and more](https://www.reddit.com/r/rust/comments/1dxdlzi/a_unified_typesystem_partial_variant_borrowed/)

---

[Ergonomic Self-Referential Types For Rust](https://blog.yoshuawuyts.com/self-referential-types/)：
* 由 Rust 异步工作组成员 Yoshua Wuyts 所写 (在一定程度上表明 async Rust 的发展方向)
* 我认为这个文章提出的设计是采用更务实（即更有可能落地）的方式支持自引用（典型应用为以安全的方式手写 Future 
  状态机），具体的设计（几乎每条罗列的设计都不是第一次提出，但却是第一次作为连贯的整体方案完整呈现）
  * 'self 生命周期标注，这使得表达自引用生命周期成为可能
  * super let 和 -> super Type 安全地支持 out-pointers / in-place construction
  * 新的 Move auto trait，用于管理（不）可移动操作 (包括 Move/?Move/!Move bounds) - 替换 Pin 
  * 基于视图类型 (view type) 的分阶段初始化 (phased initialization，即部分初始化) - 摆脱 Option 来进行初始化

[Further Simplifying Self-referential Types For Rust](https://blog.yoshuawuyts.com/self-referential-types-2/)：
* TODO

# miscellaneous

* [Benchmarking rust compilation speedups and slowdowns from sccache and -Zthreads](https://neosmart.net/blog/benchmarking-rust-compilation-speedups-and-slowdowns-from-sccache-and-zthreads/)：
  由于 WSL1 的 IO 性能较差，在那使用 sccache 可能并不会加速增量构建，反而会拖慢编译

# TODO

<https://blog.shrirambalaji.com/posts/resolving-rust-symbols/>：解析 ELF 中的 Rust 符号

<https://blog.yoshuawuyts.com/self-referential-types/>

* <https://edgl.dev/blog/rust-fn-size-trick/>：将主体代码放入单态化函数，来减少 Rust 泛型函数生成的汇编代码
  * <https://docs.rs/momo>：利用宏自动生成这种模式
